#经典一 题4
一维数组，里面每个代表一个格子，初始状态，Red 或 green 颜色；然后操作，是 两种颜色随意选一个染色覆盖格子上的颜色，一次一个格子；目标左边全Red，右边全green；最少刷格子颜色的次数
方法一：暴力法，定每个位置 N+1个分割线，看最小的
方法二：一个数组，记录从0-N，green个数，表示染色，另一个数组，从N-0记录累计要首先red色变成右边green的个数；然后从左便利分割线....
方法三：贪心策略，头尾指针，看谁只刷一个格子，跑的更远的【这个别的地方好像没看到，自己想的】

#经典一 题5,N*N数组，随机0、1在上面，以1为边界的最大正方形边长是多少？？
N*N的正方形，里面长方形个数数量级 N^4  正方形 N^3;因为厂方向随机选点N^2,另一个点随机N^2;正方形，不行，限制了边是N，则时N^2*N
【总框架的数量级无法突破，就是N^3】
1. 数据预处理 r[i][j]代表(i,j)位置点往右最多连续的1；d[i][j]代表（i,j）位置点往下最多连续的1
2. 


技巧：单cpu数量级 10^8 到10^9;c++ 1-2s全部case；java/python/.. 3-4s;
比如数据量10^6,就不能用log(N^2),至少N*log(N)

#经典二 题6，给定任意正整数M，弄出一个长度M的数组arr，里面任意的三个数，比如下标：i,j,k 那么必须arr[i]+arr[k]!=2*arr[j]
基础数据模式：[1,5,3] 达标 三个奇数：a+b!=2c 符合，那么 2a-1 ,2b-1 != 2c-1 也是符合 奇数种子
然后偶数种子：也是同样 [2,6,10]
组合[1,5,3   ,2,6,8]  抽取任意三个数，三个奇数肯定符合，三个偶数肯定符合，两个偶数一个奇数也是符合【奇数+偶数=2倍偶数，偶数加偶数均分肯定是偶数 不等于奇数】【同理两奇一偶也是】
然后M=1，情况下，返回一个数
M=2，就是三个数的种子下减去一个就行，
后面的就是组合形式

#题7：最大路劲和【路径、所有路经：变种】
#定义：是否都正数，
#路径和定义：
1.头到叶子
方式一：遍历下压传递头到叶子节点最大数字到下一层
方式二：递归从子树中找到最大的max往上传递
【注意，null的空节点不要算作路径】

2.头到叶子中某点到叶子节点

3.任意两个点
【与相对头结点最大路劲有关（相对，是因为做递归思考）】  
.与相对头无关，比较左右子树最大路劲和
.与相对头有关，头往左走最大路径和，头往右走最大路径和，然后看负数否，想不想加，到底要不要头节点，与上面的比较
【总共五种情况，设计这样一个递归函数即可】





